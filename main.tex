\documentclass{article}
\usepackage{graphicx} % Required for inserting images
\usepackage{amsmath}

\title{Formal semantics for BPMJ CMMNplus}
%\author{}

\begin{document}

\maketitle

\section{Introduction}
This supplementary document provides the complete formal semantics for the R2 and R3 extensions of the CMMN+ modeling approach. Due to space limitations in the article, this document offers a detailed mathematical specification of the semantic structures underlying the proposed extensions. The goal is to provide a precise and unambiguous foundation for interpreting the extended CMMN+ elements, ensuring rigor and reproducibility. The document is organized into two sections, corresponding to extensions R2 and R3.

\section{Formal Semantics for R2}
The R2 extension is defined through formal semantics.

First, the basic structure is introduced, namely the case model element, which is formally represented as:
\( M = \langle E, A, R \rangle \)\footnote{Angle brackets are commonly used for ordered tuples, meaning a sequence of elements where order matters. The set \( M \) is represented with angle brackets to indicate a structured object composed of multiple components in a defined order, with each component carrying a specific meaning.} where:
\begin{itemize}
    \item \( E \) is the set of all elements that constitute the model,
    \item \( A \) is the set of all attributes of elements in \( E \),
    \item \( R \) is the set of all relations between elements in the model.
\end{itemize}

We define a new set \( F \), which represents the set of all CaseFileItem elements, and specify that \( F \) is a subset of the set \( E \), as follows:
\[
F \subseteq E,
\]
where each \( f \in F \) belongs to the set of model elements \( E \) and has attributes defined by the set \( A \). Relations \( R \) are defined as subsets of the Cartesian product of the element set \( E \), written as:
\[
R \subseteq E \times E,
\]
and they may connect arbitrary elements of the model, including elements from the set \( F \). The set of attributes \( A \) includes both existing and newly introduced attributes for all model elements. Each attribute is represented as a function that maps an element \( e \in E \) to its corresponding attribute value, defined as:
\[
A = \{a_1, a_2, ..., a_k\},\quad a_i: E \rightarrow values,
\]
which implies that each attribute has a defined value. We further define a new set \( D \), representing the set of all type definitions for CaseFileItem elements, defined by the \texttt{CaseFileItemDefinition} class, expressed as:
\[
d \in D.
\]

Since each CaseFileItem element is defined by attributes of both the \texttt{CaseFileItem} class and the \texttt{CaseFileItemDefinition} class, we formalize both classes and their respective attributes. Let \( A_{\text{CaseFileItem}} \) denote the set of attributes defined in the \texttt{CaseFileItem} class, expressed as:
\[
A_{\text{CaseFileItem}} = \{ c_1, c_2, ..., c_k \},
\]
where each attribute \( c_i \in A_{\text{CaseFileItem}} \) is a function assigning a value to an element \( f \in F \), written as:
\[
c_i: F \rightarrow values,
\]
indicating that the attributes are specific to each instance \( f \in F \) and bound to its contextual definition. Similarly, let \( A_{\text{CaseFileItemDefinition}} \) denote the set of attributes defined in the \texttt{CaseFileItemDefinition} class, written as:
\[
A_{\text{CaseFileItemDefinition}} = \{ d_1, d_2, ..., d_m \},
\]
where each attribute \( d_i \in A_{\text{CaseFileItemDefinition}} \) is a function assigning a value to an element \( d \in D \), defined as:
\[
d_i: D \rightarrow values,
\]
indicating that these attributes specify the type definition for all CaseFileItem elements associated with the corresponding context.

Each element \( f \in F \) is associated with exactly one type definition from the set \( D \). This is formalized using the relation \( r_{definition} \), which connects elements in \( F \) to their corresponding type definitions in \( D \):
\[
r_{definition} \subseteq F \times D,
\]
such that for every \( f \in F \), the following holds:
\[
\exists d \in D,\ (f, d) \in r_{definition},
\]
which means that there exists a specific \( d \in D \) representing one of the type definitions assigned to the given CaseFileItem element. The pair \( (f, d) \) belongs to the relation \( r_{definition} \), linking the CaseFileItem element \( f \) to its type definition \( d \).

Each \( f \in F \) is described by a combination of attributes, where the attributes of the \texttt{CaseFileItem} class are represented as:
\[
\{ a_1(f), a_2(f), ..., a_k(f) \},
\]
where each \( a_i \in A_{\text{CaseFileItem}} \). This attribute combination also includes the attributes from the \texttt{CaseFileItemDefinition} class, which are linked to the type definition \( d \) associated with a particular CaseFileItem element \( f \), expressed as:
\[
\{ d_1(d), d_2(d), ..., d_m(d) \},
\]
where \( d_i \in A_{\text{CaseFileItemDefinition}} \). In summary, a complete CaseFileItem element can be expressed as:
\[
CaseFileItem(f) = \langle A_{\text{CaseFileItem}}(f), A_{\text{CaseFileItemDefinition}}(d) \rangle,
\]
where \( A_{\text{CaseFileItem}}(f) \) denotes the values of the attributes from the \texttt{CaseFileItem} class for element \( f \), and \( A_{\text{CaseFileItemDefinition}}(d) \) denotes the attribute values from the \texttt{CaseFileItemDefinition} class, where \( d \) is the definition linked to \( f \). The CaseFileItem element is therefore described as a combination of attributes from both classes.

The attributes of the \texttt{CaseFileItem} class are represented by the set \( A_{\text{CaseFileItem}} \), defined as:
\[
A_{\text{CaseFileItem}} = \{ ac_1, ac_2, ac_3, ac_4, ac_5, ac_6, ac_7, ac_8, ac_9, ac_{10}, ac_{11}, ac_{12} \}.
\]
The individual attributes are presented in the following sections.

Attribute \( ac_1 \) $\equiv$ \( name : F \rightarrow \text{String} \) \\
Meaning: Each element \( f \in F \) has a name, represented as a string. \\
Rule: \( name(f) \) returns a string that denotes the name of the element \( f \). \\
Constraint: \( \forall f \in F,\; name(f) \in \text{String} \wedge name(f) \neq \emptyset \). \\
Example: If \( f_1 \in F \), then \( name(f_1) = \) "Document".

\vspace{0.8em}

Attribute \( ac_2 \) $\equiv$ \( multiplicity : F \rightarrow \text{MultiplicityEnum} \) \\
Meaning: Specifies the possible number of instances of the element \( f \). \\
Rule: \( multiplicity(f) \) returns one of the defined values; the default is (1). \\
Constraint: \( \forall f \in F,\; multiplicity(f) \in \text{MultiplicityEnum} \wedge multiplicity(f) \neq \emptyset \). \\
Example: If \( f_2 \in F \) includes only one instance, then \( multiplicity(f_2) = \) "1". \\
The enumeration \text{MultiplicityEnum} is defined as:
{\begin{align*}
MultiplicityEnum = \{ (0..1), (0..*), (1), (1..*) \}.
\end{align*}}

\vspace{0.8em}

Attribute \( ac_3 \) $\equiv$ \( resourceState : F \rightarrow \text{ResourceStateEnum} \) \\
Meaning: Defines the current life cycle state of the element \( f \). \\
Rule: \( resourceState(f) \) returns one of the defined values; the default is "Unspecified". \\
Constraint: \( \forall f \in F,\; resourceState(f) \in \text{ResourceStateEnum} \wedge resourceState(f) \neq \emptyset \). \\
Example: If \( f_3 \in F \) represents a document under review, then \( resourceState(f_3) = \) "InReview". \\
The enumeration \text{ResourceStateEnum} is defined as:
{\begin{align*}
ResourceStateEnum = \{ &Draft,\;InReview,\;InApproval,\;Approved,\;Published,\nonumber \\  
&Unpublished,\;Archived,\;Canceled,\;Unspecified,\\ 
&\;Unknown \}.
\end{align*}}

Attribute \( ac_4 \) $\equiv$ \( locationRef : F \rightarrow \text{String} \) \\
Meaning: Contains a reference with the logical location of the element \( f \). \\
Rule: \( locationRef(f) \) returns a valid textual string representing the location. \\
Constraint: \( \forall f \in F,\; locationRef(f) \in (\text{String} \cup \{\emptyset\}) \). \\
Example: If \( f_4 \in F \), then \( locationRef(f_4) = \) "C:/Documents/Contract.pdf".

\vspace{0.8em}

Attribute \( ac_5 \) $\equiv$ \( access : F \rightarrow \text{AccessEnum} \) \\
Meaning: Specifies access rights to the element \( f \). \\
Rule: \( access(f) \) returns one of the defined values; the default is "Unspecified". \\
Constraint: \( \forall f \in F,\; access(f) \in \text{AccessEnum} \wedge access(f) \neq \emptyset \). \\
Example: If \( f_5 \in F \) represents a document that is public and read-only, then \( access(f_5) = \) "Public\_ReadOnly". \\
The enumeration \text{AccessEnum} is defined as:
{\begin{align*}
AccessEnum = \{ &Private\_ReadOnly,\;Private\_Editable,\;Public\_ReadOnly,\nonumber \\  
&Public\_Editable,\;Unspecified,\;Unknown \}.
\end{align*}}

Attribute \( ac_6 \) $\equiv$ \( author : F \rightarrow \text{String} \) \\
Meaning: Specifies the author who created or is associated with the element \( f \). \\
Rule: \( author(f) \) returns a valid textual string representing the name or identifier of the author. \\
Constraint: \( \forall f \in F,\; author(f) \in (\text{String} \cup \{\emptyset\}) \). \\
Example: If \( f_6 \in F \) represents a document created by "John Doe", then \( author(f_6) = \) "John Doe".

\vspace{0.8em}

Attribute \( ac_7 \) $\equiv$ \( version : F \rightarrow \text{String} \) \\
Meaning: Specifies the version of the element \( f \). \\
Rule: \( version(f) \) returns a string representing the version. \\
Constraint: \( \forall f \in F,\; version(f) \in (\text{String} \cup \{\emptyset\}) \). \\
Example: If \( f_7 \in F \) represents a document in version "1.0", then \( version(f_7) = \) "1.0".

\vspace{0.8em}

Attribute \( ac_8 \) $\equiv$ \( definitionRef : F \rightarrow D \) \\
Meaning: Each element \( f \) must be associated with exactly one type definition. \\
Rule: \( definitionRef(f) \) returns a reference to the type definition \( d \). \\
Constraint: \( \forall f \in F,\; (definitionRef(f) \in D) \wedge (definitionRef(f) \neq \emptyset) \wedge (\exists!d \in D,\; definitionRef(f) = d) \). \\
Example: If \( f_8 \in F \), then \( definitionRef(f_8) = d_1 \), where \( d_1 \in D \).

\vspace{0.8em}

Attribute \( ac_9 \) $\equiv$ \( children : F \rightarrow \mathcal{P}(F) \)\footnote{\( \mathcal{P} \) denotes the powerset and is commonly used in set theory to indicate that the attribute may contain multiple or no elements.} \\
Meaning: Indicates the subset of \( f \) that are its direct or indirect children. \\
Rule: \( children(f) \) returns the set of children of \( f \). If there are none, it returns \( \emptyset \). \\
Constraint: \( \forall f \in F,\; children(f) = \emptyset \vee children(f) \subseteq F \). \\
Example: If \( f_9 \in F \), then \( children(f_9) = \{ f_5, f_6 \} \).

\vspace{0.8em}

Attribute \( ac_{10} \) $\equiv$ \( parent : F \rightarrow F \cup \{ \emptyset \} \) \\
Meaning: Indicates the parent of the element \( f \), if it exists. \\
Rule: \( parent(f) \) returns the parent. If none exists, it returns \( \emptyset \). \\
Constraint: \( \forall f \in F,\; parent(f) \in (F \cup \{ \emptyset \}) \). \\
Example: If \( f_{10} \in F \), then \( parent(f_{10}) = f_9 \).

\vspace{0.8em}

Attribute \( ac_{11} \) $\equiv$ \( targetRefs : F \rightarrow \mathcal{P}(F) \) \\
Meaning: Indicates the set of other elements \( f \) that the element \( f \) refers to as targets. \\
Rule: \( targetRefs(f) \) returns a set of references to other \( f \) elements. If there are none, it returns \( \emptyset \). \\
Constraint: \( \forall f \in F,\; targetRefs(f) = \emptyset \vee targetRefs(f) \subseteq F \). \\
Example: If \( f_{11} \in F \), then \( targetRefs(f_{11}) = \{ f_{12}, f_{13} \} \).

\vspace{0.8em}

Attribute \( ac_{12} \) $\equiv$ \( sourceRef : F \rightarrow F \cup \{ \emptyset \} \) \\
Meaning: Indicates the source of the element \( f \), if it exists. \\
Rule: \( sourceRef(f) \) returns a reference to the source element \( f \). If none exists, it returns \( \emptyset \). \\
Constraint: \( \forall f \in F,\; sourceRef(f) \in (F \cup \{ \emptyset \}) \). \\
Example: If \( f_{12} \in F \), then \( sourceRef(f_{12}) = f_{11} \).

\vspace{1em}

The \textit{CaseFileItemDefinition} class is represented by the set \( A_{CaseFileItemDefinition} \), which includes all attributes defined within this class:
\[
A_{CaseFileItemDefinition} = \{ ad_1, ad_2, ad_3, ad_4, ad_5, ad_6, ad_7, ad_8 \}
\]
The attributes are described in the following section.

\vspace{0.8em}

Attribute \( ad_1 \) $\equiv$ \( name : D\footnote{D denotes the set of CaseFileItemDefinition instances} \rightarrow \) String \\
Meaning: Each definition \( d \in D \) has a name represented as a string. \\
Rule: \( name(d) \) returns a string indicating the name of the definition. \\
Constraint: \( \forall d \in D,\; name(d) \in String \wedge name(d) \neq \emptyset \). \\
Example: If \( d_1 \in D \) represents the definition type "Document", then \( name(d_1) = \) "Document".

\vspace{0.8em}

Attribute \( ad_2 \) $\equiv$ \( definitionType : D \rightarrow \) URI \\
Meaning: Specifies a URI that identifies the definition \( d \) for a data element \( f \). \\
Rule: \( definitionType(d) \) returns one of the predefined values, with "Unspecified" as the default. \\
Constraint: \( \forall d \in D,\; definitionType(d) \in URI \wedge definitionType(d) \neq \emptyset \). \\
Example: If \( d_2 \in D \) represents the definition "Document", then \\ 
\( definitionType(d_2) = \) "http://example.org/Document". \\
The set of allowed values for the URI is defined as:
{\begin{align*}
URI = \{ &Folder\;in\;CMIS,\;Document\;in\;CMIS, \nonumber \\ 
&Relationship\;in\;CMIS,\;XML\,-\,Schema\;Element, \nonumber \\
&XML-Schema\;Complex\;Type, XML-Schema\;Simple\;Type, \nonumber \\ 
&Unspecified,\;Unknown \}.
\end{align*}}

Attribute \( ad_3 \) $\equiv$ \( structureRef : D \rightarrow \) QName \\
Meaning: Specifies a qualified name (QName) that refers to the concrete structure of the definition. \\
Rule: \( structureRef(d) \) returns a valid QName. \\
Constraint: \( \forall d \in D,\; structureRef(d) \in (QName \cup \{\emptyset\}) \). \\
Example: If \( d_3 \in D \) represents a definition that refers to an XML Schema, then \\ 
\( structureRef(d_3) = \) "xs:ComplexType".

\vspace{0.8em}

Attribute \( ad_4 \) $\equiv$ \( description : D \rightarrow \) String \\
Meaning: Contains the textual description of the definition \( d \). \\
Rule: \( description(d) \) returns a valid string. \\
Constraint: \( \forall d \in D,\; description(d) \in (String \cup \{\emptyset\}) \). \\
Example: If \( d_4 \in D \) represents a definition for a document, then \\ 
\( description(d_4) = \) "Definition for a legal contract".

\vspace{0.8em}

Attribute \( ad_5 \) $\equiv$ \( status : D \rightarrow \mathit{StatusEnum} \) \\
Meaning: Specifies the current status of the definition \( d \) in its lifecycle. \\
Rule: \( status(d) \) returns one of the predefined values; the default is "Unspecified". \\
Constraint: \( \forall d \in D,\; status(d) \in \mathit{StatusEnum} \wedge status(d) \neq \emptyset \). \\
Example: If \( d_5 \in D \) represents a currently active definition, then \\ 
\( status(d_5) = \) "Active". \\
The enumeration for possible values is defined as:
{\begin{align*}
StatusEnum = \{ &Active, Deprecated, Archived, Unspecified, Unknown \}.
\end{align*}}

\vspace{0.8em}

Attribute \( ad_6 \) $\equiv$ \( version : D \rightarrow \) String \\
Meaning: Specifies the version of definition \( d \). \\
Rule: \( version(d) \) returns a string representing the version. \\
Constraint: \( \forall d \in D,\; version(d) \in (\text{String} \cup \{ \emptyset \}) \). \\
Example: If \( d_6 \in D \) represents a definition with version "2.0", then \\ 
\( version(d_6) = \) "2.0".

\vspace{0.8em}

Attribute \( ad_7 \) $\equiv$ \( importRef : D \rightarrow \mathit{Import} \cup \{ \emptyset \} \) \\
Meaning: Reference to an external definition for \( d \). \\
Rule: \( importRef(d) \) returns an \texttt{Import} reference or \(\emptyset\) if undefined. \\
Constraint: \( \forall d \in D,\; importRef(d) \in (\mathit{Import} \cup \{ \emptyset \}) \). \\
Example: If \( d_7 \in D \) uses an external schema, then \\
\( importRef(d_7) = \) "http://example.org/schema".

\vspace{0.8em}

Attribute \( ad_8 \) $\equiv$ \( properties : D \rightarrow \mathcal{P}(\mathit{Property}) \) \\
Meaning: A set of additional properties for the definition \( d \). \\
Rule: \( properties(d) \) returns a set of \texttt{Property}. \\
Constraint: \( \forall d \in D,\; properties(d) = \emptyset \vee properties(d) \subseteq \mathit{Property} \). \\
Example: If \( d_8 \in D \) has one property, then \\
\( properties(d_8) = \{ \text{"Size"} \} \).

\section{Formal semantics for R3}

\subsection*{Formal Semantics for Enhancement R3}

The extension R3 is presented using formal semantics.

First, the basic structure is defined, namely the case model element, which is formally represented as \( M = \langle E, A, R \rangle \), where:
\begin{itemize}
    \item \( E \) is the set of all elements that constitute the model,
    \item \( A \) is the set of all attributes of the elements in \( E \),
    \item \( R \) is the set of relations or values that can be assigned between a role and an element.
\end{itemize}

The case model element (\( M \in E \)) is a special element of the model that represents the entire case process and contains other elements.

By adding an icon (\( icon \)) to \( M \), we define the function \( f_{raci} : M \rightarrow T \), where \( T \) represents a specific subset of elements from \( E \). The set \( T \) includes only those elements in \( E \) to which roles can be directly assigned. The function \( f_{raci} \) scans the entire model \( M \), extracts all eligible elements, and maps them by assigning responsibilities (i.e., the values that can be set between a role and an element). The result of \( f_{raci}(M) \) is a RACI table that includes all elements, roles, and their corresponding responsibilities in the model \( M \). 

From the userâ€™s perspective: when the user activates \( f_{raci}(M) \) (e.g., clicks the icon), the function evaluates all elements in the set \( T \) and for each \( t_j \in T \), checks which roles, defined in \( V \), participate. For every combination of element and role, an appropriate responsibility is assigned. Formally, this can be expressed as \( icon(M) = f_{raci}(M) \), where \( f_{raci}(M) \) is a function that generates the individual responsibilities for each sub-element of the model \( M \).

We define the set of roles as \( V = \{ v_1, v_2, \ldots, v_n \} \), where each \( v_i \) represents an individual role in the model. The set of elements to which roles can be assigned is defined as \( T \), where \( T \subseteq E \)\footnote{The set \( T \) is a subset of \( E \). All elements in \( T \) are also in \( E \), but \( E \) may contain additional elements that are not part of \( T \).} within the model \( M \).

The function \( rac \) displays all responsibilities in the model and defines the relationships between roles and elements with the following structure: 
\[
rac : V \times T \rightarrow \{ R, A, S, C, I \}
\]
where \( R \) is Responsible, \( A \) is Accountable, \( S \) is Support, \( C \) is Consulted, and \( I \) is Informed. An example of the function is \( rac(v_1, t_1) = R \), which means that role \( v_1 \) is responsible for executing task \( t_1 \). Role responsibilities over elements can be represented with the semantic function \( f_{raci}(M) \), defined as:

\[
f_{raci}(M) = \{ (v_i, t_j, rac(v_i, t_j)) \mid v_i \in V, t_j \in T \}
\]

This function generates all tuples needed to build the RACI table for the entire model \( M \). The icon (\( icon \)) on \( M \) serves as an interactive component that enables access to \( f_{raci}(M) \). Semantically, clicking the icon triggers the function, expressed as: 
\[
click(icon) \Rightarrow f_{raci}(M)
\]

From the perspective of CMMN formal semantics, the addition of the icon to the case model element for displaying the RACI table is equivalent to adding a function that determines the responsibilities for all relevant elements in the model in accordance with the RACI rules.

Definitions of elements to which roles can be assigned impose certain restrictions regarding the assignable RACI values. Below are elements with their allowed RACI assignments.
\begin{itemize}
    \item For the user task element \( UO \), any RACI value may be assigned: \\
    \( UO \rightarrow \{ R, A, S, C, I \} \)
    \item For the manual task element \( RO \), any RACI value may be assigned: \\
    \( RO \rightarrow \{ R, A, S, C, I \} \)
    \item For the user event listener element \( P \), only the value \textit{Responsible} is valid: \\
    \( P \rightarrow \{ R \} \)
\end{itemize}

\section{Conclusion}
The formal semantics defined in this document provide a rigorous basis for the proposed CMMN+ extensions. By explicitly defining the structural and behavioral properties of the extended elements, we facilitate precise model interpretation, tool support, and theoretical analysis. These semantics complement the visual and descriptive representations in the BPMJ article and are intended as a reference for researchers and practitioners adopting the CMMN+ approach.

\end{document}
